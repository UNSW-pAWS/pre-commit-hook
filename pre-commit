#!/usr/bin/env python3

import sys, os, re ,json , subprocess, requests
from subprocess import check_output, run
import queue
from json.decoder import JSONDecodeError

exit_status = 0

def task(location, work_queue):
    global exit_status
    with requests.Session() as session:
        while not work_queue.empty():
            package = work_queue.get()
            r = session.post('http://dependency.eba-suunxfcc.ap-southeast-2.elasticbeanstalk.com/threat/search',json={"package_manager_type" : "npm","package_list" : [package],"level": 0, "severity": ["CRITICAL"], "date": "None"})
            yield
            if r.status_code == 200:
                r_content = r.json()
                for h in r_content:
                    if len(r_content[h][1]) != 0:
                        print("The package {} in your {} is vulnerable. Please visit our website at http://www.google.com for more information".format(h,location))
                        exit_status = 1


result = run(
        ["git", "rev-parse", "HEAD"],
        stdout=subprocess.PIPE,
        stderr=subprocess.DEVNULL,
        check=False
    )

if result.stdout.decode("utf-8") == "HEAD":
    file_to_commit = check_output([ 'git', 'diff', '--cached', '--name-status' , 'HEAD'])
else:
    file_to_commit = check_output([ 'git', 'diff', '--cached', '--name-status'])
file_to_commit = file_to_commit.decode("utf-8")
file_to_commit = file_to_commit.replace("M\t", " ")
file_to_commit = file_to_commit.replace("C\t", " ")
file_to_commit = file_to_commit.replace("R\t", " ")
file_to_commit = file_to_commit.replace("A\t", " ")
file_to_commit = file_to_commit.replace("U\t", " ")
file_to_commit = file_to_commit.strip()
file_to_commit = file_to_commit.split(" ")

for i in file_to_commit:
    if "D\t" in i.strip():
        continue
    if "package.json" in i.strip():
        if os.stat(i.strip()).st_size == 0:
            print("WARNING:\tYour file {} is empty. You may want to check that you did not make a mistake".format(i.strip()))
        else:
            f = open(i.strip(),)
            try:
                data = json.load(f)
                if "dependencies" in data:
                    work_queue = queue.Queue()
                    package_list = list(data["dependencies"].keys())
                    for package in package_list:
                        work_queue.put(package)
                    tasks = [task("dependencies",work_queue) for _ in range(0, max(1,int(len(package_list)/2)))]
                    print("Scanning your dependencies. Please hold on tight")
                    done = False
                    while not done:
                        for t in tasks:
                            try:
                                next(t)
                            except StopIteration:
                                tasks.remove(t)
                            if len(tasks) == 0:
                                done = True
                if "devDependencies" in data:
                    work_queue = queue.Queue()
                    package_list = list(data["devDependencies"].keys())
                    for package in package_list:
                        work_queue.put(package)
                    tasks = [task("devDependencies",work_queue) for _ in range(0, max(1,int(len(package_list)/2)))]
                    print("Scanning your devdependencies. Please hold on tight")
                    done = False
                    while not done:
                        for t in tasks:
                            try:
                                next(t)
                            except StopIteration:
                                tasks.remove(t)
                            if len(tasks) == 0:
                                done = True
                f.close()
                if (exit_status == 1):
                    print("You have some files with critical vulnerbilities, please solve those before commiting again.")
            except JSONDecodeError:
                print("WARNING:\tYour file {} is not readable as a json file. Please check that you did not make a mistake".format(i.strip()))
                f.close()
                exit_status =1
exit(exit_status)